# 마이크로서비스 아키텍처

## 일상화된 마이크로서비스 아키텍처

B21 스텔스 폭격기는 마이크로서비스 아키텍처와 쿠버네티스에 기반해 다목적 임무 수행(폭격, 전투 지휘, 정보 수집)이 가능한 형태로 제작됨

## 서비스 중심의 아키텍처

- 경계가 지어진 맥락에서 결합도가 낮은 구성 요소를 포함
- 네트워크로 통신 + 개별적으로 서비스 업데이트
- 다른 마이크로서비스 내부를 모르면서 코드를 업데이트 가능

## 이점

### 간소화된 배포

- 지속적인 통합과 배포(CI/CD)로 출시 시간 단축

### 필요에 따라 성능 확장

- 서비스마다 독립적인 컨테이너 또는 데이터 플랫폼 확장 가능

### 고가용성 확보

- 전체 애플리케이션에 영향을 주지 않고 독립적으로 서비스 교체 가능

배포는 사람이 안한다. 자동화

금융권은 무조건 수동 배포 → 자동배포를 하면 

## 요소

### 인프라 구성 요소

- 퍼블릭 클라우드
- 컨테이너, 서버리스
- 컨테이너 오케스트레이션

### 플랫폼

- 서비스 레지스트리: 서비스 등록/탐색
- API 게이트웨이 : 다양한 API 조합 제공, 인증/인가/추적 처리
- 외부 구성 저장소: 데이터베이스 연결 정보, 파일 스토리지 정보
- 로깅, 모니터링과 추적

### 애플리케이션

- 동기/비동기 통신 방식: RESTful API와 메시지 브로커
- 저장소 분리: 각자 비즈니스를 위한 데이터 직접 소유
- 동기보다 비동기가 성능적으로 좋다

## 플랫폼

- 자바를 사용하면  **GraalVM**
- 쿠버네티스 도커
- 모니터링에 많이 사용되는 grafana , Prometheus, kibana
- cncf

## 컨테이너 레지스트리

- 컨테이너 이미지를 안전하게 저장하고 공유하는 관리형 도커 레지스트리 서비스
관리형 쿠버네티스와 연계, CI/CD 도구와 연계
- OKE
    - 관리형 컨테이너
    - 오케스트레이션 서비스
    - 원 클릭 클러스터 생성
    - 클러스터 관리 비용 무료!
- EKS
- AKS
- GKE
- 쿠버네티스 짱!

### Oracle Cloud Functions

서버리스

- 요청이 올때만 서버가 자동으로 띄어진다

- (서버리스) 코드 작성 후 배포만 하면 자동 프로비저닝/확장 가능
- 도커 이미지로 자동 패키징
- 파이썬/고/자바 지원

FN → 서버리스 

코테 플랫폼

# **개발자 서비스 부문**

### API 게이트웨이

- API 수명 주기를 관리하는 서비스
- API 개발을 위한 apiary 연계

### 데브옵스

- Visual Builder Studio를 사용해 소프트웨어 전 개발 주기 지원
- CI/CD 플랫폼 지원
- 테라폼 지원
- 모니터링과 로깅 지원

CI/CD 플랫폼 지원

테라폼 지원

모니터링과 로깅 지원

# **관찰 능력과 관리 부문**

### APM(중요!!)

- 운영에 도움이 된다
- 관측성을 높이기 위한 분산 추적 서비스
- OpenTracing과 OpenTelementry지원

### 데이터베이스 관리

- 모니터링/관리 단위를 그룹으로 묶어 간소화
- CDB와 PDB 별로 그룹화한 다음에 관리 가능
    - 데이터베이슬 하나를 쓰더라도 잘 분리하자(멀티 테넌트 데이터베이스)

### 오라클 데이터베이스

- 자율 관리형 오라클 데이터베이스 지원

### IAM

- 생명주기와 자격 관리를 통한 자원에 대한 접근 제어(SSO/MFA) 지원
- 권한에 대한 관리 중요

### 배스티언(Bastion)

- 공용 엔드포인트 없이 클라우드 자원에 대한 접근
- SSH 접근 가시성 확보, 관리 단순화

### OCI는 마이크로서비스 아키텍처 구현에 있어 다음과 같은 장점

- GraalVM : 서버리스나 VM의 크기를 줄이고 성능을 높임
- 관리형 k8s인 OKE: 컨테이너 관리를 원할하게 함
- 오픈소스 기반의 서비르스인 Functions: GraalVM과 결합되어 위력을 발휘함
- 자율 데이터베이스의 컨버지드 데이터베이스: 데이터베이스 분할을 쉽게 수행함

## Hello, Kafka

### Kafka란?

- Linkedin 내부 문제 해결을 위한 Jay Kreps 개발
- Publish/Subscribe 구조의 메시지 브로커
- 2012년 오프소스화
- Confluent에서 Kafka와 Ecosystem 개발

### 특징

- High Throughput
- 실시간 로그 통합
- 무중단
- 이기종과의 호환성
- 간단한 스케일 아웃
- 프로듀서와 컨슈머 역할 분리
- 확장성
- 영속성: 디스크 저장, Durability
- 유연성: 연계 기술 및 플러그인
- 신뢰송: 메시지 전달 보증 기능 제공
- 실시간 & 배치

### kafka 이전 : Messaging System

- 메시지 큐
    - IBM MQ JMS(Java Messaging System)
    - ActiveMQ, RabbitMQ
- 전달 보증으로 인한 오버 스펙
    - JMS는 Commit/Rollback 제공

### UseCase

- 다른 종류의 에코 시스템과 연결하기 위한 메시지 버스
- 실시간 파이프라인과 배치 파이프라인
- 데이터 종류 별로 멀티 클러스터를 만들고 데이터 선터 간 연결

### 초기 설계 원칙

- producer와 consumer 분리
- 메시징 시스템과 같이 영구 메시지 데이터를 여러 컨슈머에게 허용
- 높은 처리량을 위한 메시지 최적화
- 데이터가 증가함에 따라 스케일아웃이 가능한 시스템

### Messaging Architecture

- Pub/Sub model

### 프로듀서와 컨슈머의 분리

- 웹 서버에서 요청을 보낼때 카프카로 다 보낸다.

### 특징

- 디스크 메시지 저장
    - 기존 메시지 시스템과 차별성
    - 일반적으로 큐에 저장후 전송 후 삭제
    - Kafka는 일정 기간 메시지 보관
    - Consumer의 지연처리 및 재처리에 매우 유리
- 확장성
    - 지속적 확장성
    - 무중단 확장성

### Kafka 발전 방향

- 카프카를 통한 고성능의 펍/섭 모델이 가능
- 서비스 기반 아키텍처SOA, Service Oriented Architecture의 엔터프라이즈 서비스 버스(ESB, Enterpreise Service Bus) 구현 용이
- SOA는 업무를 서비스라는 단위로 분리
- 빅데이터 분석 파이프라인(RDW)

### 넷플릭스에서는 카프칸에 저장된 정보로 뭘 할까?

- 알고리즘
- 컨텐츠 추천

### ksql

- Kafka에서 사용하는 sql